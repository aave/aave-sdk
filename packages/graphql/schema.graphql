type APRSample {
  """The avg rate"""
  avgRate: DecimalValue!

  """The date"""
  date: DateTime!
}

input AmountInput @oneOf {
  """The native amount"""
  native: BigDecimal

  """The erc20 amount input"""
  erc20: Erc20AmountInput
}

"""
Indicates that an approval transaction must be performed before proceeding to the next step.
"""
type ApprovalRequired {
  """The transaction requires an approval first"""
  approval: TransactionRequest!
  reason: String!

  """The required amount missing to be able to do the original transaction"""
  requiredAmount: DecimalValue!

  """The current allowance approved"""
  currentAllowance: DecimalValue!

  """The transaction to send after the approval is complete"""
  originalTransaction: TransactionRequest!
}

scalar BigDecimal

scalar BigInt

scalar BlockchainData

input BorrowAPRHistoryRequest {
  """The market pool address"""
  market: EvmAddress!

  """The underlying token for the reserve"""
  underlyingToken: EvmAddress!

  """The time windows for the history"""
  window: TimeWindow!

  """The chain id"""
  chainId: ChainId!
}

input BorrowRequest {
  """The market pool address"""
  market: EvmAddress!

  """The amount borrowing"""
  amount: AmountInput!

  """The user who is borrowing"""
  borrower: EvmAddress!

  """
  This should be the address of the borrower if they want to borrow against their own collateral,
  """
  onBehalfOf: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

type Chain {
  """The chain name"""
  name: String!

  """The chain icon"""
  icon: String!

  """The chain id"""
  chainId: ChainId!

  """Explorer URL"""
  explorerUrl: String!
}

scalar ChainId

input CollateralToggleRequest {
  """The pool address for the market"""
  market: EvmAddress!

  """The underlying token for the reserve"""
  underlyingToken: EvmAddress!

  """The user to toggle emode on"""
  user: EvmAddress!

  """The chain id"""
  chainId: ChainId!
}

type Currency {
  """The token address"""
  address: EvmAddress!

  """The chain id"""
  chainId: ChainId!

  """The token name"""
  name: String!

  """The token image"""
  imageUrl: String!

  """The token symbol"""
  symbol: String!

  """The token decimals"""
  decimals: Int!
}

scalar Cursor

scalar DateTime

input DebtToCover @oneOf {
  """Exact debt amount to cover"""
  exact: BigDecimal

  """Maximum debt amount (equivalent to uint(-1))"""
  max: Boolean
}

type DecimalValue {
  """The raw none formatted value"""
  raw: BigInt!

  """The decimals the value formatted into"""
  decimals: Int!

  """The formatted value"""
  value: BigDecimal!
}

input ERC712Signature {
  """The signature for the erc721"""
  value: Signature!

  """The deadline for the erc721"""
  deadline: DateTime!
}

type EmodeMarketCategory {
  """The eMode id for the market"""
  id: Int!

  """The eMode label"""
  label: String!

  """The maximum loan-to-value ratio in efficiency mode"""
  maxLTV: DecimalValue!

  """The liquidation threshold in efficiency mode"""
  liquidationThreshold: DecimalValue!

  """The liquidation penalty applied in efficiency mode"""
  liquidationPenalty: DecimalValue!

  """The list of reserves which will tailor for this eMode"""
  reserves: [EmodeMarketReserveInfo!]!
}

type EmodeMarketReserveInfo {
  """The underlying token used on the reserve"""
  underlyingToken: Currency!

  """If the underlying token can be collateral with this eMode on"""
  canBeCollateral: Boolean!

  """If the underlying token can be borrowed with this eMode on"""
  canBeBorrowed: Boolean!
}

"""The emode reserve information"""
type EmodeReserveInfo {
  """The eMode category id for the market"""
  categoryId: Int!

  """The eMode label"""
  label: String!

  """The maximum loan-to-value ratio in efficiency mode"""
  maxLTV: DecimalValue!

  """The liquidation threshold in efficiency mode"""
  liquidationThreshold: DecimalValue!

  """The liquidation penalty applied in efficiency mode"""
  liquidationPenalty: DecimalValue!

  """If the underlying token can be collateral with this eMode on"""
  canBeCollateral: Boolean!

  """If the underlying token can be borrowed with this eMode on"""
  canBeBorrowed: Boolean!
}

input Erc20AmountInput {
  """The token address."""
  currency: EvmAddress!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g.,
  wei).
  """
  value: BigDecimal!

  """The erc712 signature, which can also be used for permit functionality"""
  erc712: ERC712Signature
}

scalar EvmAddress

"""
An execution plan represents what needs to happen to fulfill a requested operation.
It could be an immediate transaction, an approval followed by a transaction, or indicate insufficient balance.
"""
union ExecutionPlan = TransactionRequest | ApprovalRequired | InsufficientBalanceError

"""
Indicates the user does not have enough balance to perform the operation.
"""
type InsufficientBalanceError {
  """The amount required to do the original transaction"""
  required: DecimalValue!

  """The amount available in the wallet"""
  available: DecimalValue!
}

input LiquidateRequest {
  """The market pool address"""
  market: EvmAddress!

  """
  The address of the token used as collateral, to receive as result of the liquidation
  """
  collateralToken: EvmAddress!

  """
  The address of the underlying borrowed token to be repaid with the liquidation
  """
  underlyingToken: EvmAddress!

  """The address of the borrower getting liquidated"""
  user: EvmAddress!

  """
  The debt amount of the underlying borrowed token the liquidator will repay
  """
  debtToCover: DebtToCover! = {max: true}

  """
  true if the liquidator wants to receive the aTokens equivalent of the purchased collateral, false if they want to receive the collateral asset directly
  """
  receiveAToken: Boolean! = false

  """The chain id"""
  chainId: ChainId!
}

"""Information about collateral liquidated in a liquidation call."""
type LiquidationCollateral {
  """Reserve of the collateral."""
  reserve: ReserveInfo!

  """Amount of collateral liquidated"""
  amount: TokenAmount
}

"""Information about debt repaid in a liquidation call."""
type LiquidationRepaidDebt {
  """Reserve of the repaid debt."""
  reserve: ReserveInfo!

  """Amount of debt repaid."""
  amount: TokenAmount!
}

type Market {
  """The human-friendly name for the market"""
  name: String!

  """The chain"""
  chain: Chain!

  """The liquidity pool address for the market"""
  address: EvmAddress!

  """A list eModes the market can support"""
  eModeCategories: [EmodeMarketCategory!]!
  userState: MarketUserState

  """The market icon"""
  icon: String!

  """The market reserves"""
  reserves(request: MarketReservesRequest! = {reserveType: BOTH, orderBy: {tokenName: ASC}}): [Reserve!]!

  """The total market size"""
  totalMarketSize: BigDecimal!

  """The total available liquidity in USD"""
  totalAvailableLiquidity: BigDecimal!
}

type MarketInfo {
  """The human-friendly name for the market"""
  name: String!

  """The chain"""
  chain: Chain!

  """The liquidity pool address for the market"""
  address: EvmAddress!

  """The market icon"""
  icon: String!
}

input MarketInput {
  """The address of the market pool"""
  address: EvmAddress!

  """The chain id the market is deployed on"""
  chainId: ChainId!
}

input MarketRequest {
  """The pool address for the market"""
  address: EvmAddress!

  """The chain id the market pool address is deployed on"""
  chainId: ChainId!

  """
  The user viewing it (can be connected wallet) - this caters for stuff like eMode and other user features
  """
  user: EvmAddress
}

input MarketReservesRequest {
  """The reserve type"""
  reserveType: MarketReservesRequestType! = BOTH

  """The way the reserve gets ordered on the return result"""
  orderBy: MarketReservesRequestOrderBy! = {tokenName: ASC}
}

input MarketReservesRequestOrderBy @oneOf {
  """Order by the borrow APY"""
  borrowApy: OrderDirection

  """Order by the supply APY"""
  supplyApy: OrderDirection

  """Order by whether the asset can be used as collateral"""
  canBeCollateralized: OrderDirection

  """Order by the token name"""
  tokenName: OrderDirection

  """Order by the amount available for the user to borrow"""
  userAvailableToBorrow: OrderByUserCriteria

  """Order by the user's balance of this asset"""
  userBalance: OrderByUserCriteria
}

enum MarketReservesRequestType {
  SUPPLY
  BORROW
  BOTH
}

type MarketUserReserveBorrowPosition {
  """The market address where this position exists"""
  market: MarketInfo!

  """The currency being borrowed"""
  currency: Currency!

  """The user's debt balance in this reserve"""
  debt: TokenAmount!

  """The annual percentage yield for this borrow position"""
  apy: DecimalValue!
}

type MarketUserReserveSupplyPosition {
  """The market address where this position exists"""
  market: MarketInfo!

  """The currency being supplied"""
  currency: Currency!

  """The user's supply balance in this reserve"""
  balance: TokenAmount!

  """The annual percentage yield for this supply position"""
  apy: DecimalValue!

  """Whether this position is being used as collateral"""
  isCollateral: Boolean!

  """If the asset can be used for collateral"""
  canBeCollateral: Boolean!
}

type MarketUserState {
  """The user's total net worth in the market"""
  netWorth: BigDecimal!

  """The user's net annual percentage yield across all positions"""
  netAPY: BigDecimal!

  """The user's health factor (risk metric for liquidation)"""
  healthFactor: BigDecimal!

  """Whether efficiency mode is enabled for the user"""
  eModeEnabled: Boolean!

  """
  The total collateral of the user in the base currency used by the price feed
  """
  totalCollateralBase: BigDecimal!

  """The total debt of the user in the base currency used by the price feed"""
  totalDebtBase: BigDecimal!

  """
  The borrowing power left of the user in the base currency used by the price feed
  """
  availableBorrowsBase: BigDecimal!

  """The liquidation threshold of the user"""
  currentLiquidationThreshold: BigDecimal!

  """The loan to value of the user"""
  ltv: BigDecimal!

  """One of the user collateral is in isolation mode"""
  isInIsolationMode: Boolean!
}

input MarketsRequest {
  """The markets you want to see based on the chain ids"""
  chainIds: [ChainId!]!

  """
  The user viewing it (can be connected wallet) - this caters for stuff like eMode and other
  user features
  """
  user: EvmAddress
}

type NativeCurrency {
  """The token image"""
  imageUrl: String!

  """The token name"""
  name: String!

  """The token symbol"""
  symbol: String!

  """The token decimals"""
  decimals: Int!

  """The chain id"""
  chainId: ChainId!
}

input OrderByUserCriteria {
  """The address of the user"""
  address: EvmAddress!

  """The order direction"""
  direction: OrderDirection! = DESC
}

enum OrderDirection {
  ASC
  DESC
}

enum PageSize {
  TEN
  FIFTY
}

type PaginatedResultInfo {
  """The cursor to the previous page of results, if any."""
  prev: Cursor

  """The cursor to the next page of results, if any."""
  next: Cursor
}

"""Paginated result of user transaction history."""
type PaginatedUserTransactionHistoryResult {
  """List of user transaction items."""
  items: [UserTransactionItem!]!

  """Pagination information."""
  pageInfo: PaginatedResultInfo!
}

type PaginatedVaultsResult {
  items: [Vault!]!
  pageInfo: PaginatedResultInfo!
}

type Query {
  """Get if the API is healthy"""
  health: Boolean!

  """All chains the protocol supports"""
  chains: [Chain!]!

  """
  Deposits assets (underlying tokens or its related aTokens) into the vault and mints a corresponding amount of vault shares to the receiver.
  """
  vaultDeposit(request: VaultDepositRequest!): ExecutionPlan!

  """
  Redeems shares (vault shares) for the underlying assets or a tokens, which are sent to the receiver. The shares are burned from the owner.
  """
  vaultRedeemShares(request: VaultRedeemSharesRequest!): TransactionRequest!

  """Get a vault"""
  vault(request: VaultRequest!): Vault

  """Get vaults"""
  vaults(request: VaultsRequest!): PaginatedVaultsResult!

  """User vaults they have shares in"""
  userVaults(request: UserVaultsRequest!): PaginatedVaultsResult!

  """Deploy a vault and earn fees from the yield"""
  vaultDeploy(request: VaultDeployRequest!): TransactionRequest!

  """
  Update a vault's fee. You MUST be the owner of the vault to send this tx request.
  """
  vaultSetFee(request: VaultSetFeeRequest!): TransactionRequest!

  """
  Withdraws accumulated fees from the specified vault. You MUST be the owner of the vault to send this tx request.
  """
  vaultWithdrawFees(request: VaultWithdrawFeesRequest!): TransactionRequest!

  """
  Claim rewards from the specified vault. You MUST be the owner of the vault to send this tx request.
  """
  vaultClaimRewards(request: VaultClaimRewardsRequest!): TransactionRequest!

  """
  Withdraws assets (underlying tokens or its related aTokens) from the vault and sends them to the receiver. The corresponding vault shares are burned from the owner.
  """
  vaultWithdraw(request: VaultWithdrawRequest!): TransactionRequest!

  """
  Mints an exact amount of shares (vault shares) to the receiver by depositing the calculated amount of underlying or aTokens assets.
  """
  vaultMintShares(request: VaultMintSharesRequest!): ExecutionPlan!

  """Lists all the markets"""
  markets(request: MarketsRequest!): [Market!]!

  """Get a market"""
  market(request: MarketRequest!): Market

  """Create the transaction to borrow from a market"""
  borrow(request: BorrowRequest!): ExecutionPlan!

  """Create the transaction to supply to a market"""
  supply(request: SupplyRequest!): ExecutionPlan!

  """Create the transaction to repay to a market"""
  repay(request: RepayRequest!): ExecutionPlan!

  """Create the transaction to withdraw from a market"""
  withdraw(request: WithdrawRequest!): ExecutionPlan!

  """Create the transaction to toggle eMode for a market"""
  userSetEmode(request: UserSetEmodeRequest!): TransactionRequest!

  """Enable/disable a specific supplied asset as collateral"""
  collateralToggle(request: CollateralToggleRequest!): TransactionRequest!

  """
  liquidate a non-healthy position collateral-wise, with Health Factor below 1
  """
  liquidate(request: LiquidateRequest!): TransactionRequest!

  """Returns the user account market data across all the reserves."""
  userMarketState(request: UserMarketStateRequest!): MarketUserState!

  """The usd exchange rates for different tokens on a given market"""
  usdExchangeRates(request: UsdExchangeRatesRequest!): [UsdExchangeRate!]!

  """Get all the user borrows positions"""
  userBorrows(request: UserBorrowsRequest!): [MarketUserReserveBorrowPosition!]!

  """Get all the user supplies positions"""
  userSupplies(request: UserSuppliesRequest!): [MarketUserReserveSupplyPosition!]!

  """Get the borrow APR history"""
  borrowAPRHistory(request: BorrowAPRHistoryRequest!): [APRSample!]!

  """Get the supply APR history"""
  supplyAPRHistory(request: SupplyAPRHistoryRequest!): [APRSample!]!

  """Get the reserve for on a market"""
  reserve(request: ReserveRequest!): Reserve

  """The user's transaction history"""
  userTransactionHistory(request: UserTransactionHistoryRequest!): PaginatedUserTransactionHistoryResult!
  _service: _Service!
}

input RepayRequest {
  """The market pool address"""
  market: EvmAddress!

  """
  The amount to repay - you can pass in the underlying or the aToken if you pass in the aToken address it will repay with the aToken
  """
  amount: AmountInput!

  """The user who is repaying"""
  borrower: EvmAddress!

  """
  The address of the user who will get their debt reduced/removed. This should be the address of the user calling the function if they want to
  """
  onBehalfOf: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

type Reserve {
  """The market information the reserve is under"""
  market: MarketInfo!

  """The reserve underlying currency"""
  underlyingToken: Currency!

  """The reserve a token"""
  aToken: Currency!

  """The reserve v token"""
  vToken: Currency!

  """
  If the reserve accepts native currency, for example, if you're on a reserve with asset WETH, it can
  also accept ETH
  """
  acceptsNative: NativeCurrency

  """The reserve size"""
  size: TokenAmount!

  """The usd exchange rate for the underlying token"""
  usdExchangeRate: BigDecimal!

  """The usd oracle address it is pulling that price from"""
  usdOracleAddress: EvmAddress!

  """The supply info for the reserve"""
  supplyInfo: ReserveSupplyInfo!

  """
  The borrow info for the reserve - if its null the underlying token cannot be borrowed
  """
  borrowInfo: ReserveBorrowInfo

  """The reserve has been frozen all actions are stopped"""
  isFrozen: Boolean!

  """The reserve is paused you can still withdraw and some other actions"""
  isPaused: Boolean!

  """
  If the reserve supports isolation mode this is defined and the configs are defined
  """
  isolationModeConfig: ReserveIsolationModeConfig

  """If the reserve can use flash loans on it"""
  flashLoanEnabled: Boolean!

  """A list eModes the reserve can support"""
  eModeInfo: [EmodeReserveInfo!]!

  """
  The state of the user in the context of this reserve, note this can change borrow and supply criteria
  """
  userState: ReserveUserState
}

type ReserveBorrowInfo {
  """The annual percentage yield for borrowing this asset"""
  apy: DecimalValue!

  """The total amount borrowed from this reserve"""
  total: TokenAmount!

  """The reserve factor percentage"""
  reserveFactor: DecimalValue!

  """The available liquidity"""
  availableLiquidity: TokenAmount!

  """The reserve utilization rate"""
  utilizationRate: DecimalValue!

  """
  Variable rate slope 1 - the rate of interest increase when utilization rate is below optimal
  This is the slope of the interest rate curve in the first segment (0% to optimal utilization)
  """
  variableRateSlope1: DecimalValue!

  """
  Variable rate slope 2 - the rate of interest increase when utilization rate is above optimal
  This is the slope of the interest rate curve in the second segment (optimal to 100% utilization)
  Typically much steeper than slope1 to discourage over-utilization
  """
  variableRateSlope2: DecimalValue!

  """
  The optimal usage rate - the utilization rate at which the variable rate curve transitions
  from slope1 to slope2. This represents the target utilization rate for the reserve
  """
  optimalUsageRate: DecimalValue!

  """
  Borrowing can have different states based on the criteria of the user or the market
  """
  borrowingState: ReserveBorrowingState!

  """The borrow cap of the reserve"""
  borrowCap: TokenAmount!

  """The borrow cap is now full"""
  borrowCapReached: Boolean!
}

enum ReserveBorrowingState {
  """Borrowing is enabled"""
  ENABLED

  """Borrowing is disabled"""
  DISABLED

  """The user emode settings make this underlying not able to be borrowed"""
  USER_EMODE_DISABLED_BORROW
}

type ReserveInfo {
  """The market information the reserve is under"""
  market: MarketInfo!

  """The reserve underlying currency"""
  underlyingToken: Currency!

  """The reserve a token"""
  aToken: Currency!

  """The reserve v token"""
  vToken: Currency!

  """The usd exchange rate for the underlying token"""
  usdExchangeRate: BigDecimal!
}

type ReserveIsolationModeConfig {
  """This means that it can be used to borrow"""
  canBeCollateral: Boolean!
  canBeBorrowed: Boolean!
  debtCeiling: TokenAmount!

  """Only the amount that is borrowed by the users in isolation"""
  totalBorrows: TokenAmount!
}

input ReserveRequest {
  """The pool address for the market"""
  market: EvmAddress!

  """The underlying token for the reserve"""
  underlyingToken: EvmAddress!

  """The chain id the pool is deployed on"""
  chainId: ChainId!

  """
  The user viewing it (can be connected wallet) - this caters for stuff like eMode and other
  user features
  """
  user: EvmAddress
}

type ReserveSupplyInfo {
  """The annual percentage yield for supplying this asset"""
  apy: DecimalValue!

  """The maximum loan-to-value ratio when used as collateral"""
  maxLTV: DecimalValue!

  """The liquidation threshold for this asset"""
  liquidationThreshold: DecimalValue!

  """The liquidation bonus applied when liquidated"""
  liquidationBonus: DecimalValue!

  """If the asset can be used for collateral"""
  canBeCollateral: Boolean!

  """The supply cap"""
  supplyCap: TokenAmount!

  """The supply cap is now full"""
  supplyCapReached: Boolean!

  """The total amount supplied to this reserve"""
  total: DecimalValue!
}

type ReserveUserState {
  """The user's balance of this asset"""
  balance: TokenAmount!

  """The amount the user can supply to this reserve"""
  suppliable: TokenAmount!

  """The amount the user can borrow from this reserve"""
  borrowable: TokenAmount!

  """The user emode info if enabled"""
  emode: EmodeReserveInfo

  """
  If the user is in a state to be able to supply taking into consideration their emode
  """
  canBeCollateral: Boolean!

  """If the user is in a state to be able to borrow from the reserve"""
  canBeBorrowed: Boolean!

  """Is the user in isolation mode"""
  isInIsolationMode: Boolean!
}

scalar Signature

input SupplyAPRHistoryRequest {
  """The market pool address"""
  market: EvmAddress!

  """The underlying token for the reserve"""
  underlyingToken: EvmAddress!

  """The time windows for the history"""
  window: TimeWindow!

  """The chain id"""
  chainId: ChainId!
}

input SupplyRequest {
  """The market pool address"""
  market: EvmAddress!

  """The amount supplying"""
  amount: AmountInput!

  """The user who is supplying"""
  supplier: EvmAddress!

  """
  The address that will receive the corresponding aTokens. This is the only address that will be able to withdraw the asset from the pool.
  This will be the same as msg.sender if the user wants to receive aTokens into their own wallet, or use a different address if the beneficiary
  of aTokens is a different wallet
  """
  onBehalfOf: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

enum TimeWindow {
  LAST_DAY
  LAST_WEEK
  LAST_MONTH
  LAST_SIX_MONTHS
  LAST_YEAR
}

type TokenAmount {
  usdPerToken: BigDecimal!

  """The amount"""
  amount: DecimalValue!

  """The usd full amount"""
  usd: BigDecimal!
}

"""
Represents a transaction that must be executed, such as a direct supply, borrow, etc.
"""
type TransactionRequest {
  to: EvmAddress!
  from: EvmAddress!
  data: BlockchainData!
  value: BigInt!
  chainId: ChainId!
}

scalar TxHash

type UsdExchangeRate {
  currency: Currency!
  rate: BigDecimal!
}

input UsdExchangeRatesRequest {
  """The pool address for the market"""
  market: EvmAddress!

  """The underlying tokens for the reserve"""
  underlyingTokens: [EvmAddress!]!

  """The chain id"""
  chainId: ChainId!
}

"""A transaction where the user borrowed assets from a reserve."""
type UserBorrowTransaction {
  """Amount borrowed."""
  amount: TokenAmount!

  """Reserve from which assets were borrowed."""
  reserve: ReserveInfo!

  """URL to view the transaction on a block explorer."""
  blockExplorerUrl: String!

  """Transaction hash."""
  txHash: TxHash!

  """Timestamp of the transaction."""
  timestamp: DateTime!
}

input UserBorrowsRequest {
  """The market addresses and chains ids to query"""
  markets: [MarketInput!]!

  """The user address to get borrow positions for"""
  user: EvmAddress!

  """How to order the results"""
  orderBy: UserBorrowsRequestOrderBy! = {name: ASC}
}

input UserBorrowsRequestOrderBy @oneOf {
  """Order by the user's debt amount"""
  debt: OrderByUserCriteria

  """Order by the asset name"""
  name: OrderDirection

  """Order by the annual percentage yield"""
  apy: OrderDirection
}

"""A transaction where the user was involved in a liquidation call."""
type UserLiquidationCallTransaction {
  """Collateral liquidated."""
  collateral: LiquidationCollateral!

  """Debt repaid."""
  debtRepaid: LiquidationRepaidDebt!

  """URL to view the transaction on a block explorer."""
  blockExplorerUrl: String!

  """Transaction hash."""
  txHash: TxHash!

  """Timestamp of the transaction."""
  timestamp: DateTime!
}

input UserMarketStateRequest {
  """The pool address for the market"""
  market: EvmAddress!

  """The user to toggle emode on"""
  user: EvmAddress!

  """The chain id"""
  chainId: ChainId!
}

"""A transaction where the user repaid borrowed assets."""
type UserRepayTransaction {
  """Amount repaid."""
  amount: TokenAmount!

  """Reserve to which assets were repaid."""
  reserve: ReserveInfo!

  """URL to view the transaction on a block explorer."""
  blockExplorerUrl: String!

  """Transaction hash."""
  txHash: TxHash!

  """Timestamp of the transaction."""
  timestamp: DateTime!
}

input UserSetEmodeRequest {
  """The pool address for the market"""
  market: EvmAddress!

  """The user to toggle emode on"""
  user: EvmAddress!

  """
  The eMode category id for the market if you want to disable eMode, then pass in null
  """
  categoryId: Int

  """The chain id"""
  chainId: ChainId!
}

input UserSuppliesRequest {
  """The market addresses and chains ids to query"""
  markets: [MarketInput!]!

  """The user address to get supply positions for"""
  user: EvmAddress!

  """Only get back the supplies which can be used as collateral"""
  collateralsOnly: Boolean! = false

  """How to order the results"""
  orderBy: UserSuppliesRequestOrderBy! = {name: ASC}
}

input UserSuppliesRequestOrderBy @oneOf {
  """Order by the user's supply balance"""
  balance: OrderByUserCriteria

  """Order by the asset name"""
  name: OrderDirection

  """Order by the annual percentage yield"""
  apy: OrderDirection

  """Order by whether the position is used as collateral"""
  isCollateralized: OrderByUserCriteria
}

"""A transaction where the user supplied assets to a reserve."""
type UserSupplyTransaction {
  """Amount supplied."""
  amount: TokenAmount!

  """Reserve to which assets were supplied."""
  reserve: ReserveInfo!

  """URL to view the transaction on a block explorer."""
  blockExplorerUrl: String!

  """Transaction hash."""
  txHash: TxHash!

  """Timestamp of the transaction."""
  timestamp: DateTime!
}

input UserTransactionHistoryRequest {
  """The market address"""
  market: EvmAddress!

  """The filter to optionally filter the transactions by type"""
  filter: [UserTransactionType!]! = [SUPPLY, WITHDRAW, BORROW, REPAY, USAGE_AS_COLLATERAL, LIQUIDATION_CALL]

  """The order by object to sort the transactions by"""
  orderBy: UserTransactionHistoryRequestOrderBy! = {date: ASC}

  """The user that sent the transactions"""
  user: EvmAddress!

  """The chain id where the transactions were sent"""
  chainId: ChainId!

  """The page size"""
  pageSize: PageSize! = FIFTY

  """Pagination cursor"""
  cursor: Cursor
}

input UserTransactionHistoryRequestOrderBy {
  """Order by the date of the transaction"""
  date: OrderDirection
}

union UserTransactionItem = UserSupplyTransaction | UserWithdrawTransaction | UserBorrowTransaction | UserRepayTransaction | UserUsageAsCollateralTransaction | UserLiquidationCallTransaction

"""The type of user transaction in the protocol."""
enum UserTransactionType {
  """User supplied assets to the protocol."""
  SUPPLY

  """User borrowed assets from the protocol."""
  BORROW

  """User enabled or disabled usage of an asset as collateral."""
  USAGE_AS_COLLATERAL

  """User was involved in a liquidation call."""
  LIQUIDATION_CALL

  """User repaid a borrowed amount."""
  REPAY

  """User withdrew supplied assets."""
  WITHDRAW
}

"""
A transaction where the user enabled or disabled usage of an asset as collateral.
"""
type UserUsageAsCollateralTransaction {
  """Whether collateral usage was enabled."""
  enabled: Boolean!

  """Reserve for which collateral usage was changed."""
  reserve: ReserveInfo!

  """URL to view the transaction on a block explorer."""
  blockExplorerUrl: String!

  """Transaction hash."""
  txHash: TxHash!

  """Timestamp of the transaction."""
  timestamp: DateTime!
}

type UserVaultShares {
  """The user's shares on the vault"""
  shares: TokenAmount!

  """The amount they have deposited on the vault"""
  amountDeposited: TokenAmount!

  """The amount they have withdrawn on the vault"""
  amountWithdrawn: TokenAmount!
}

input UserVaultsFilter {
  """Filter by markets"""
  vaults: [VaultInput!]

  """Filter by underlying token addresses"""
  underlyingTokens: [EvmAddress!]
}

input UserVaultsOrderBy @oneOf {
  """Order by shares"""
  shares: OrderDirection

  """Order by deposited amount in USD"""
  depositedInUsd: OrderDirection

  """Order by fee"""
  fee: OrderDirection
}

input UserVaultsRequest {
  """The user address"""
  user: EvmAddress!

  """Filter criteria"""
  filters: UserVaultsFilter

  """Ordering criteria"""
  orderBy: UserVaultsOrderBy! = {shares: ASC}

  """The page size"""
  pageSize: PageSize! = FIFTY

  """Pagination cursor"""
  cursor: Cursor
}

"""A transaction where the user withdrew assets from a reserve."""
type UserWithdrawTransaction {
  """Amount withdrawn."""
  amount: TokenAmount!

  """Reserve from which assets were withdrawn."""
  reserve: ReserveInfo!

  """URL to view the transaction on a block explorer."""
  blockExplorerUrl: String!

  """Transaction hash."""
  txHash: TxHash!

  """Timestamp of the transaction."""
  timestamp: DateTime!
}

type Vault {
  """The vault address"""
  address: EvmAddress!

  """The owner of the vault"""
  owner: EvmAddress!

  """The name of the share"""
  shareName: String!

  """The symbol of the share"""
  shareSymbol: String!

  """The reserve the vault is using"""
  usedReserve: Reserve!

  """The current fee percentage set for the vault."""
  fee: BigDecimal!

  """How much this vault has made in revenue"""
  totalFeeRevenue: TokenAmount!

  """
  The last recorded balance of the vault's AToken. This value is updated when yield is accrued.
  """
  balance: TokenAmount!

  """The chain id the vault lives on"""
  chainId: ChainId!

  """The user's shares info on the vault"""
  userShares: UserVaultShares
}

input VaultClaimRewardsRequest {
  """The vault deployed address"""
  vault: EvmAddress!

  """Who the rewards go to - if not supplied, it goes to the owner"""
  sendTo: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

input VaultDeployRequest {
  """Underlying token address."""
  underlyingToken: EvmAddress!

  """The market address."""
  market: EvmAddress!

  """The chain id"""
  chainId: ChainId!

  """
  The address to set as which deploys the vault and will become an owner of the vault.
  """
  deployer: EvmAddress!

  """The owner of the vault - if not defined, it will be the deployer"""
  owner: EvmAddress

  """The initial fee to set, expressed in %."""
  initialFee: BigDecimal!

  """The name to set for the vault's shares."""
  shareName: String!

  """The symbol to set for the vault's shares."""
  shareSymbol: String!

  """
  The initial amount of underlying assets to deposit. This must be a non-zero, non-trivial amount, depending on the underlying asset's decimals.
  """
  initialLockDeposit: BigDecimal!
}

input VaultDepositRequest {
  """The vault address"""
  vault: EvmAddress!

  """
  The amount of assets to deposit - you can pass in the underlying or the aToken if you pass in the aToken address it will deposit with the aToken
  """
  amount: Erc20AmountInput!

  """The user who is depositing"""
  depositor: EvmAddress!

  """
  The address to which vault shares will be minted to - defaults to depositor.
  """
  sharesRecipient: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

input VaultInput {
  """The address of the fault"""
  address: EvmAddress!

  """The chain id the vault is on"""
  chainId: ChainId!
}

input VaultMintSharesRequest {
  """The vault address"""
  vault: EvmAddress!

  """The amount of shares to mint"""
  shares: VaultShareInput!

  """The user who is wanting to mint the shares"""
  minter: EvmAddress!

  """
  The address to which vault shares will be minted to - defaults to minter.
  """
  sharesRecipient: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

input VaultRedeemSharesRequest {
  """The vault address"""
  vault: EvmAddress!

  """The shares to redeem."""
  shares: VaultShareInput!

  """
  The address from which vault shares will be burned (normally your own wallet).
  """
  sharesOwner: EvmAddress!

  """
  If you are doing the redeem from a trusted wallet which can move funds on behalf of the shares owner (advanced usage)
  """
  authorizedUser: EvmAddress

  """
  The address to which the underlying assets will be sent; if not set it will go to the sharesOwner
  """
  recipient: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

input VaultRequest {
  """The retrieve criteria"""
  by: VaultRequestBy!

  """The chain id the vault is deployed on"""
  chainId: ChainId!

  """
  The user viewing it (can be connected wallet) - this caters for stuff like userShares and other user features
  """
  user: EvmAddress
}

input VaultRequestBy @oneOf {
  """The vault address"""
  address: EvmAddress

  """
  You can use this if you deployed a vault and want to get the vault information using the tx hash after the receipt is given
  """
  txHash: TxHash
}

input VaultSetFeeRequest {
  """The vault deployed address"""
  vault: EvmAddress!

  """The new fee to set, expressed in %."""
  newFee: BigDecimal!

  """The chain id"""
  chainId: ChainId!
}

input VaultShareInput {
  """The amount of vault shares"""
  amount: BigDecimal!

  """Whether the amount should be sent/received as aToken."""
  asAToken: Boolean! = false

  """The authorization to redeem the shares."""
  signature: ERC712Signature
}

input VaultWithdrawFeesRequest {
  """The vault deployed address"""
  vault: EvmAddress!

  """
  Who the withdrawal fees will go to - if not supplied, it goes to the owner
  """
  sendTo: EvmAddress

  """Human-formatted amount"""
  amount: BigDecimal!

  """The chain id"""
  chainId: ChainId!
}

input VaultWithdrawRequest {
  """The vault address"""
  vault: EvmAddress!

  """The shares to withdraw."""
  shares: VaultShareInput!

  """
  The address from which vault shares will be burned (normally your own wallet).
  """
  sharesOwner: EvmAddress!

  """
  If you are doing the withdrawal from a trusted wallet which can move funds on behalf of the shares owner (advanced usage)
  """
  authorizedUser: EvmAddress

  """
  The address to which the underlying assets will be sent - defaults to sharesOwner.
  """
  recipient: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

input VaultsRequest {
  """Filter criteria for vaults"""
  criteria: VaultsRequestFilterCriteria!

  """
  The user viewing it (can be connected wallet) - this caters for stuff like userShares and other user features
  """
  user: EvmAddress

  """The page size"""
  pageSize: PageSize! = FIFTY

  """Pagination cursor"""
  cursor: Cursor
}

input VaultsRequestFilterCriteria @oneOf {
  """Filter by specific vault addresses"""
  vaults: [VaultInput!]

  """Filter by owner addresses"""
  ownedBy: [EvmAddress!]
}

input WithdrawAmountInput @oneOf {
  """The native amount"""
  native: WithdrawNativeAmountInput

  """The erc20 amount input"""
  erc20: WithdrawErc20AmountInput
}

input WithdrawErc20AmountInput {
  """The token address."""
  currency: EvmAddress!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g., wei).
  """
  value: BigDecimal!
}

input WithdrawNativeAmountInput {
  """The native value"""
  value: BigDecimal!

  """The permit for the transaction if required"""
  permit: ERC712Signature
}

input WithdrawRequest {
  """The market pool address"""
  market: EvmAddress!

  """The amount to withdraw"""
  amount: WithdrawAmountInput!

  """
  The user who is withdrawing, this should have the `aToken` that will be burned by the `Pool`
  """
  supplier: EvmAddress!

  """
  The address that will receive the underlying asset. This will go to the supplier if the user wants to receive the tokens into
  their own wallet, or use a different address if the beneficiary is a different wallet
  """
  recipient: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

type _Service {
  sdl: String
}