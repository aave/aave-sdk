input AmountInput @oneOf {
  """The native amount"""
  native: BigDecimal

  """The erc20 amount input"""
  erc20: Erc20AmountInput
}

"""
Indicates that an approval transaction must be performed before proceeding to the next step.
"""
type ApprovalRequired {
  """The transaction requires an approval first"""
  approval: TransactionRequest!
  reason: String!

  """The required amount missing to be able to do the original transaction"""
  requiredAmount: DecimalValue!

  """The current allowance approved"""
  currentAllowance: DecimalValue!

  """The transaction to send after the approval is complete"""
  originalTransaction: TransactionRequest!
}

scalar BigDecimal

scalar BigInt

scalar BlockchainData

input BorrowRequest {
  """The market pool address"""
  market: EvmAddress!

  """The amount borrowing"""
  amount: AmountInput!

  """The user who is borrowing"""
  borrower: EvmAddress!

  """
  This should be the address of the borrower if they want to borrow against their own collateral,
  """
  onBehalfOf: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

type Chain {
  """The chain name"""
  name: String!

  """The chain id"""
  chainId: ChainId!
}

scalar ChainId

input ClaimVaultRewardsRequest {
  """The vault deployed address"""
  vault: EvmAddress!

  """Who the rewards go to - if not supplied, it goes to the owner"""
  sendTo: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

input CollateralToggleRequest {
  """The pool address for the market"""
  market: EvmAddress!

  """The underlying token for the reserve"""
  underlyingToken: EvmAddress!

  """The user to toggle emode on"""
  user: EvmAddress!

  """The chain id"""
  chainId: ChainId!
}

type Currency {
  """The token address"""
  address: EvmAddress!

  """The chain id"""
  chainId: ChainId!

  """The token name"""
  name: String!

  """The token image"""
  imageUrl: String!

  """The token symbol"""
  symbol: String!

  """The token decimals"""
  decimals: Int!
}

scalar Cursor

scalar DateTime

input DebtToCover @oneOf {
  """Exact debt amount to cover"""
  exact: BigDecimal

  """Maximum debt amount (equivalent to uint(-1))"""
  max: Boolean
}

type DecimalValue {
  """The raw none formatted value"""
  raw: BigInt!

  """The decimals the value formatted into"""
  decimals: Int!

  """The formatted value"""
  value: BigDecimal!
}

input DeployVaultRequest {
  """Underlying token address."""
  underlyingToken: EvmAddress!

  """The market address."""
  market: EvmAddress!

  """The chain id"""
  chainId: ChainId!

  """
  The address to set as which deploys the vault and will become a owner of the vault.
  """
  deployer: EvmAddress!

  """The initial fee to set, expressed in %."""
  initialFee: BigDecimal!

  """The name to set for the vault's shares."""
  shareName: String!

  """The symbol to set for the vault's shares."""
  shareSymbol: String!

  """
  The initial amount of underlying assets to deposit. This must be a non-zero, non-trivial amount, depending on the underlying asset's decimals.
  """
  initialLockDeposit: BigDecimal!
}

input ERC712Signature {
  """The signature for the erc721"""
  value: Signature!

  """The deadline for the erc721"""
  deadline: DateTime!
}

type EmodeMarketCategory {
  """The eMode label"""
  label: String!

  """The maximum loan-to-value ratio in efficiency mode"""
  maxLTV: DecimalValue!

  """The liquidation threshold in efficiency mode"""
  liquidationThreshold: DecimalValue!

  """The liquidation penalty applied in efficiency mode"""
  liquidationPenalty: DecimalValue!

  """
  If you have passed in the user address, this will tell you if they have this eMode enabled
  (they can only have 1 enabled at once)
  """
  userEnabled: Boolean!

  """The list of reserves which will tailor for this eMode"""
  reserves: [EmodeMarketReserveInfo!]!
}

type EmodeMarketReserveInfo {
  """The underlying token used on the reserve"""
  underlyingToken: Currency!

  """If the underlying token can be collateral with this eMode on"""
  canBeCollateral: Boolean!

  """If the underlying token can be borrowable with this eMode on"""
  canBeBorrowable: Boolean!
}

type EmodeReserveInfo {
  """The eMode label"""
  label: String!

  """The maximum loan-to-value ratio in efficiency mode"""
  maxLTV: DecimalValue!

  """The liquidation threshold in efficiency mode"""
  liquidationThreshold: DecimalValue!

  """The liquidation penalty applied in efficiency mode"""
  liquidationPenalty: DecimalValue!

  """
  If you have passed in the user address, this will tell you if they have this eMode enabled
  (they can only have 1 enabled at once)
  """
  userEnabled: Boolean!

  """If the underlying token can be collateral with this eMode on"""
  canBeCollateral: Boolean!

  """If the underlying token can be borrowable with this eMode on"""
  canBeBorrowable: Boolean!
}

input EmodeToggleRequest {
  """The pool address for the market"""
  market: EvmAddress!

  """The user to toggle emode on"""
  user: EvmAddress!

  """The chain id"""
  chainId: ChainId!
}

input Erc20AmountInput {
  """The token address."""
  currency: EvmAddress!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g.,
  wei).
  """
  value: BigDecimal!

  """The erc712 signature, which can also be used for permit functionality"""
  erc712: ERC712Signature
}

scalar EvmAddress

"""
An execution plan represents what needs to happen to fulfill a requested operation.
It could be an immediate transaction, an approval followed by a transaction, or indicate insufficient balance.
"""
union ExecutionPlan = TransactionRequest | ApprovalRequired | InsufficientBalanceError

"""
Indicates the user does not have enough balance to perform the operation.
"""
type InsufficientBalanceError {
  """The amount required to do the original transaction"""
  required: DecimalValue!

  """The amount available in the wallet"""
  available: DecimalValue!
}

input LiquidateRequest {
  """
  The address of the token used as collateral, to receive as result of the liquidation
  """
  collateralToken: EvmAddress!

  """
  The address of the underlying borrowed token to be repaid with the liquidation
  """
  underlyingToken: EvmAddress!

  """The address of the borrower getting liquidated"""
  user: EvmAddress!

  """
  The debt amount of the underlying borrowed token the liquidator will repay
  """
  debtToCover: DebtToCover! = {max: true}

  """
  true if the liquidator wants to receive the aTokens equivalent of the purchased collateral, false if they want to receive the collateral asset directly
  """
  receiveAToken: Boolean! = false

  """The chain id"""
  chainId: ChainId!
}

type Market {
  """The human-friendly name for the market"""
  name: String!

  """The chain"""
  chain: Chain!

  """The liquidity pool address for the market"""
  address: EvmAddress!

  """The total borrows on the market"""
  totalBorrows: BigDecimal!

  """A list eModes the market can support"""
  eModeCategories: [EmodeMarketCategory!]!

  """The market icon"""
  icon: String!

  """The market reserves"""
  reserves(request: MarketReservesRequest! = {reserveType: BOTH, orderBy: {tokenName: ASC}}): [Reserve!]!

  """The total market size"""
  totalMarketSize: BigDecimal!

  """The total available liquidity in USD"""
  totalAvailableLiquidity: BigDecimal!

  """The market user stats"""
  userStats: MarketUserStats
}

type MarketInfo {
  """The human-friendly name for the market"""
  name: String!

  """The chain"""
  chain: Chain!

  """The market icon"""
  icon: String!
}

input MarketRequest {
  """The pool address for the market"""
  address: EvmAddress!

  """The chain id the market pool address is deployed on"""
  chainId: ChainId!

  """
  The user viewing it (can be connected wallet) - this caters for stuff like eMode and other user features
  """
  user: EvmAddress
}

input MarketReservesRequest {
  """The reserve type"""
  reserveType: MarketReservesRequestType! = BOTH

  """The way the reserve gets ordered on the return result"""
  orderBy: MarketReservesRequestOrderBy! = {tokenName: ASC}
}

input MarketReservesRequestOrderBy @oneOf {
  """Order by the borrow APY"""
  borrowApy: OrderDirection

  """Order by the supply APY"""
  supplyApy: OrderDirection

  """Order by whether the asset can be used as collateral"""
  canBeCollateralized: OrderDirection

  """Order by the token name"""
  tokenName: OrderDirection

  """Order by the amount available for the user to borrow"""
  userAvailableToBorrow: OrderByUserCriteria

  """Order by the user's balance of this asset"""
  userBalance: OrderByUserCriteria
}

enum MarketReservesRequestType {
  SUPPLY
  BORROW
  BOTH
}

type MarketUserStats {
  """The user's total net worth in the market"""
  netWorth: DecimalValue!

  """The user's net annual percentage yield across all positions"""
  netAPY: DecimalValue!

  """The user's health factor (risk metric for liquidation)"""
  healthFactor: DecimalValue!

  """Whether efficiency mode is enabled for the user"""
  eModeEnabled: Boolean!

  """
  The total collateral of the user in the base currency used by the price feed
  """
  totalCollateralBase: DecimalValue!

  """The total debt of the user in the base currency used by the price feed"""
  totalDebtBase: DecimalValue!

  """
  The borrowing power left of the user in the base currency used by the price feed
  """
  availableBorrowsBase: DecimalValue!

  """The liquidation threshold of the user"""
  currentLiquidationThreshold: DecimalValue!

  """The loan to value of the user"""
  ltv: DecimalValue!
}

input MarketsRequest {
  """The markets you want to see based on the chain ids"""
  chainIds: [ChainId!]!

  """
  The user viewing it (can be connected wallet) - this caters for stuff like eMode and other
  user features
  """
  user: EvmAddress
}

input MintVaultSharesRequest {
  """The vault address"""
  vault: EvmAddress!

  """The amount of shares to mint"""
  shares: VaultShareInput!

  """The user who is wanting to mint the shares"""
  minter: EvmAddress!

  """
  The address to which vault shares will be minted to - defaults to minter.
  """
  sharesRecipient: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

type NativeCurrency {
  """The token image"""
  imageUrl: String!

  """The token name"""
  name: String!

  """The token symbol"""
  symbol: String!

  """The token decimals"""
  decimals: Int!

  """The chain id"""
  chainId: ChainId!
}

input OrderByUserCriteria {
  """The address of the user"""
  address: EvmAddress!

  """The order direction"""
  direction: OrderDirection! = DESC
}

enum OrderDirection {
  ASC
  DESC
}

enum PageSize {
  TEN
  FIFTY
}

type PaginatedResultInfo {
  """The cursor to the previous page of results, if any."""
  prev: Cursor

  """The cursor to the next page of results, if any."""
  next: Cursor
}

type PaginatedVaultsResult {
  items: [Vault!]!
  pageInfo: PaginatedResultInfo!
}

type Query {
  """Get if the API is healthy"""
  health: Boolean!

  """All chains the protocol supports"""
  chains: [Chain!]!

  """
  Deposits assets (underlying tokens or its related aTokens) into the vault and mints a corresponding amount of vault shares to the receiver.
  """
  vaultDeposit(request: VaultDepositRequest!): ExecutionPlan!

  """
  Redeems shares (vault shares) for the underlying assets or a tokens, which are sent to the receiver. The shares are burned from the owner.
  """
  redeemVaultShares(request: VaultRedeemSharesRequest!): TransactionRequest!

  """Get a vault"""
  vault(request: VaultRequest!): Vault

  """Get vaults"""
  vaults(request: VaultsRequest!): PaginatedVaultsResult!

  """User vaults they have shares in"""
  userVaults(request: UserVaultsRequest!): PaginatedVaultsResult!

  """Deploy a vault and earn fees from the yield"""
  deployVault(request: DeployVaultRequest!): TransactionRequest!

  """
  Update a vault's fee. You MUST be the owner of the vault to send this tx request.
  """
  setVaultFee(request: SetVaultFeeRequest!): TransactionRequest!

  """
  Withdraws accumulated fees from the specified vault. You MUST be the owner of the vault to send this tx request.
  """
  withdrawVaultFees(request: WithdrawVaultFeesRequest!): TransactionRequest!

  """
  Claim rewards from the specified vault. You MUST be the owner of the vault to send this tx request.
  """
  claimVaultRewards(request: ClaimVaultRewardsRequest!): TransactionRequest!

  """
  Withdraws assets (underlying tokens or its related aTokens) from the vault and sends them to the receiver. The corresponding vault shares are burned from the owner.
  """
  withdrawVault(request: WithdrawVaultRequest!): TransactionRequest!

  """
  Mints an exact amount of shares (vault shares) to the receiver by depositing the calculated amount of underlying or aTokens assets.
  """
  mintVaultShares(request: MintVaultSharesRequest!): ExecutionPlan!

  """Lists all the markets"""
  markets(request: MarketsRequest!): [Market!]!

  """Get a market"""
  market(request: MarketRequest!): Market

  """Create the transaction to borrow from a market"""
  borrow(request: BorrowRequest!): ExecutionPlan!

  """Create the transaction to supply to a market"""
  supply(request: SupplyRequest!): ExecutionPlan!

  """Create the transaction to repay to a market"""
  repay(request: RepayRequest!): ExecutionPlan!

  """Create the transaction to withdraw from a market"""
  withdraw(request: WithdrawRequest!): ExecutionPlan!

  """Create the transaction to toggle eMode for a market"""
  eModeToggle(request: EmodeToggleRequest!): TransactionRequest!

  """Enable/disable a specific supplied asset as collateral"""
  collateralToggle(request: CollateralToggleRequest!): TransactionRequest!

  """
  liquidate a non-healthy position collateral-wise, with Health Factor below 1
  """
  liquidate(request: LiquidateRequest!): TransactionRequest!

  """Returns the user account market data across all the reserves."""
  userMarketStats(request: UserMarketStatsRequest!): MarketUserStats!

  """The usd exchange rates for different tokens on a given market"""
  usdExchangeRates(request: UsdExchangeRatesRequest!): [UsdExchangeRate!]!

  """Get all the user supplies positions"""
  userSupplies(request: UserSuppliesRequest!): [UserReserveSupplyPosition!]!

  """Get all the user borrows positions"""
  userBorrows(request: UserBorrowsRequest!): [UserReserveBorrowPosition!]!

  """Get the reserve for on a market"""
  reserve(request: ReserveRequest!): Reserve
  _service: _Service!
}

input RepayRequest {
  """The market pool address"""
  market: EvmAddress!

  """
  The amount to repay - you can pass in the underlying or the aToken if you pass in the aToken address it will repay with the aToken
  """
  amount: AmountInput!

  """The user who is repaying"""
  borrower: EvmAddress!

  """
  The address of the user who will get their debt reduced/removed. This should be the address of the user calling the function if they want to
  """
  onBehalfOf: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

type Reserve {
  """The market information the reserve is under"""
  market: MarketInfo!

  """The reserve underlying currency"""
  underlyingToken: Currency!

  """The reserve a token"""
  aToken: Currency!

  """The reserve v token"""
  vToken: Currency!

  """
  If the reserve accepts native currency, for example, if you're on a reserve with asset WETH, it can
  also accept ETH
  """
  acceptsNative: NativeCurrency

  """The reserve size"""
  size: TokenAmount!

  """The usd exchange rate for the underlying token"""
  usdExchangeRate: BigDecimal!

  """The usd oracle address it is pulling that price from"""
  usdOracleAddress: EvmAddress!

  """The supply info for the reserve"""
  supplyInfo: ReserveSupplyInfo!

  """
  The borrow info for the reserve - if its null the underlying token cannot be borrowed
  """
  borrowInfo: ReserveBorrowInfo

  """A list eModes the reserve can support"""
  eModeInfo: [EmodeReserveInfo!]!

  """The reserve has been frozen all actions are stopped"""
  isFrozen: Boolean!

  """The reserve is paused you can still withdraw and some other actions"""
  isPaused: Boolean!

  """
  The user's availability on the reserve to borrow and supply with balance
  """
  userAvailability: ReserveUserAvailability
}

type ReserveBorrowInfo {
  """The annual percentage yield for borrowing this asset"""
  apy: DecimalValue!

  """The total amount borrowed from this reserve"""
  total: TokenAmount!

  """The reserve factor percentage"""
  reserveFactor: DecimalValue!

  """The available liquidity"""
  availableLiquidity: TokenAmount!

  """The reserve utilization rate"""
  utilizationRate: DecimalValue!

  """
  Borrowing can have different states based on criteria of the user or the market
  """
  borrowingState: ReserveBorrowingState!

  """The borrow cap of the reserve"""
  borrowCap: TokenAmount!

  """The borrow cap is now full"""
  borrowCapReached: Boolean!
}

enum ReserveBorrowingState {
  """Borrowing is enabled"""
  ENABLED

  """Borrowing is disabled"""
  DISABLED

  """The user emode settings make this underlying not able to be borrowed"""
  USER_EMODE_DISABLED_BORROW
}

input ReserveRequest {
  """The pool address for the market"""
  market: EvmAddress!

  """The underlying token for the reserve"""
  underlyingToken: EvmAddress!

  """The chain id the pool is deployed on"""
  chainId: ChainId!

  """
  The user viewing it (can be connected wallet) - this caters for stuff like eMode and other
  user features
  """
  user: EvmAddress
}

type ReserveSupplyInfo {
  """The annual percentage yield for supplying this asset"""
  apy: DecimalValue!

  """The maximum loan-to-value ratio when used as collateral"""
  maxLTV: DecimalValue!

  """The liquidation threshold for this asset"""
  liquidationThreshold: DecimalValue!

  """The liquidation bonus applied when liquidated"""
  liquidationBonus: DecimalValue!

  """If the asset can be used for collateral"""
  canBeCollateral: Boolean!

  """The supply cap"""
  supplyCap: TokenAmount!

  """The supply cap is now full"""
  supplyCapReached: Boolean!

  """The total amount supplied to this reserve"""
  total: DecimalValue!
}

type ReserveUserAvailability {
  """The user's balance of this asset"""
  balance: DecimalValue!

  """The amount the user can supply to this reserve"""
  supply: DecimalValue!

  """The amount the user can borrow from this reserve"""
  borrow: DecimalValue!
}

input SetVaultFeeRequest {
  """The vault deployed address"""
  vault: EvmAddress!

  """The new fee to set, expressed in %."""
  newFee: BigDecimal!

  """The chain id"""
  chainId: ChainId!
}

scalar Signature

input SupplyRequest {
  """The market pool address"""
  market: EvmAddress!

  """The amount supplying"""
  amount: AmountInput!

  """The user who is supplying"""
  supplier: EvmAddress!

  """
  The address that will receive the corresponding aTokens. This is the only address that will be able to withdraw the asset from the pool.
  This will be the same as msg.sender if the user wants to receive aTokens into their own wallet, or use a different address if the beneficiary
  of aTokens is a different wallet
  """
  onBehalfOf: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

type TokenAmount {
  usdPerToken: BigDecimal!

  """The amount"""
  amount: DecimalValue!

  """The usd full amount"""
  usd: BigDecimal!
}

"""
Represents a transaction that must be executed, such as a direct supply, borrow, etc.
"""
type TransactionRequest {
  to: EvmAddress!
  from: EvmAddress!
  data: BlockchainData!
  value: BigInt!
  chainId: ChainId!
}

type UsdExchangeRate {
  currency: Currency!
  rate: BigDecimal!
}

input UsdExchangeRatesRequest {
  """The pool address for the market"""
  market: EvmAddress!

  """The underlying tokens for the reserve"""
  underlyingTokens: [EvmAddress!]!

  """The chain id"""
  chainId: ChainId!
}

input UserBorrowsRequest {
  """The market addresses to query"""
  markets: [EvmAddress!]!

  """The user address to get borrow positions for"""
  user: EvmAddress!

  """How to order the results"""
  orderBy: UserBorrowsRequestOrderBy! = {name: ASC}
}

input UserBorrowsRequestOrderBy @oneOf {
  """Order by the user's debt amount"""
  debt: OrderByUserCriteria

  """Order by the asset name"""
  name: OrderDirection

  """Order by the annual percentage yield"""
  apy: OrderDirection
}

input UserMarketStatsRequest {
  """The pool address for the market"""
  market: EvmAddress!

  """The user to toggle emode on"""
  user: EvmAddress!

  """The chain id"""
  chainId: ChainId!
}

type UserReserveBorrowPosition {
  """The market address where this position exists"""
  market: EvmAddress!

  """The currency being borrowed"""
  currency: Currency!

  """The user's debt balance in this reserve"""
  debt: DecimalValue!

  """The annual percentage yield for this borrow position"""
  apy: DecimalValue!
}

type UserReserveSupplyPosition {
  """The market address where this position exists"""
  market: EvmAddress!

  """The currency being supplied"""
  currency: Currency!

  """The user's supply balance in this reserve"""
  balance: DecimalValue!

  """The annual percentage yield for this supply position"""
  apy: DecimalValue!

  """Whether this position is being used as collateral"""
  isCollateral: Boolean!

  """If the asset can be used for collateral"""
  canBeCollateral: Boolean!
}

input UserSuppliesRequest {
  """The market addresses to query"""
  markets: [EvmAddress!]!

  """The user address to get supply positions for"""
  user: EvmAddress!

  """Only get back the supplies which can be used as collateral"""
  collateralsOnly: Boolean! = false

  """How to order the results"""
  orderBy: UserSuppliesRequestOrderBy! = {name: ASC}
}

input UserSuppliesRequestOrderBy @oneOf {
  """Order by the user's supply balance"""
  balance: OrderByUserCriteria

  """Order by the asset name"""
  name: OrderDirection

  """Order by the annual percentage yield"""
  apy: OrderDirection

  """Order by whether the position is used as collateral"""
  isCollateralized: OrderByUserCriteria
}

input UserVaultsFilter {
  """Filter by market addresses"""
  markets: [EvmAddress!]

  """Filter by underlying token addresses"""
  underlyingTokens: [EvmAddress!]
}

input UserVaultsOrderBy @oneOf {
  """Order by shares"""
  shares: OrderDirection

  """Order by deposited amount in USD"""
  depositedInUsd: OrderDirection

  """Order by fee"""
  fee: OrderDirection
}

input UserVaultsRequest {
  """The user address"""
  user: EvmAddress!

  """Filter criteria"""
  filters: UserVaultsFilter

  """Ordering criteria"""
  orderBy: UserVaultsOrderBy! = {shares: ASC}

  """The page size"""
  pageSize: PageSize! = FIFTY

  """Pagination cursor"""
  cursor: Cursor
}

type Vault {
  """The vault address"""
  address: EvmAddress!

  """The owner of the vault"""
  owner: EvmAddress!

  """The name of the share"""
  shareName: String!

  """The symbol of the share"""
  shareSymbol: String!

  """The reserve the vault is using"""
  usedReserve: Reserve!

  """The current fee percentage set for the vault."""
  fee: BigDecimal!

  """
  The last recorded balance of the vault's AToken. This value is updated when yield is accrued.
  """
  balance: TokenAmount!

  """
  Reports the total assets managed by the vault, net of fees, for vault share logic.
  """
  totalAssets: TokenAmount!

  """The chain id the vault lives on"""
  chainId: ChainId!

  """The user's shares on the vault"""
  userShares(address: EvmAddress!): DecimalValue!
}

input VaultDepositRequest {
  """The vault address"""
  vault: EvmAddress!

  """
  The amount of assets to deposit - you can pass in the underlying or the aToken if you pass in the aToken address it will deposit with the aToken
  """
  amount: Erc20AmountInput!

  """The user who is depositing"""
  depositor: EvmAddress!

  """
  The address to which vault shares will be minted to - defaults to depositor.
  """
  sharesRecipient: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

input VaultRedeemSharesRequest {
  """The vault address"""
  vault: EvmAddress!

  """The shares to redeem."""
  shares: VaultShareInput!

  """
  The address from which vault shares will be burned (normally your own wallet).
  """
  sharesOwner: EvmAddress!

  """
  If you are doing the redeem from a trusted wallet which can move funds on behalf of the shares owner (advanced usage)
  """
  authorizedUser: EvmAddress

  """The address to which the underlying assets will be sent."""
  recipient: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

input VaultRequest {
  """The vault address"""
  address: EvmAddress!

  """The chain id the vault is deployed on"""
  chainId: ChainId!
}

input VaultShareInput {
  """The amount of vault shares to redeem."""
  amount: BigDecimal!

  """Whether the amount should be sent as aToken."""
  asAToken: Boolean! = false

  """The authorization to redeem the shares."""
  signature: ERC712Signature
}

input VaultsRequest {
  """Filter criteria for vaults"""
  criteria: VaultsRequestFilterCriteria!

  """The page size"""
  pageSize: PageSize! = FIFTY

  """Pagination cursor"""
  cursor: Cursor
}

input VaultsRequestFilterCriteria @oneOf {
  """Filter by specific vault addresses"""
  vaults: [EvmAddress!]

  """Filter by owner addresses"""
  ownedBy: [EvmAddress!]
}

input WithdrawAmountInput @oneOf {
  """The native amount"""
  native: WithdrawNativeAmountInput

  """The erc20 amount input"""
  erc20: WithdrawErc20AmountInput
}

input WithdrawErc20AmountInput {
  """The token address."""
  currency: EvmAddress!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g., wei).
  """
  value: BigDecimal!
}

input WithdrawNativeAmountInput {
  """The native value"""
  value: BigDecimal!

  """The permit for the transaction if required"""
  permit: ERC712Signature
}

input WithdrawRequest {
  """The market pool address"""
  market: EvmAddress!

  """The amount to withdraw"""
  amount: WithdrawAmountInput!

  """
  The user who is withdrawing, this should have the `aToken` that will be burned by the `Pool`
  """
  supplier: EvmAddress!

  """
  The address that will receive the underlying asset. This will go to the supplier if the user wants to receive the tokens into
  their own wallet, or use a different address if the beneficiary is a different wallet
  """
  recipient: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

input WithdrawVaultFeesRequest {
  """The vault deployed address"""
  vault: EvmAddress!

  """
  Who the withdrawal fees will go to - if not supplied, it goes to the owner
  """
  sendTo: EvmAddress

  """Human-formatted amount"""
  amount: BigDecimal!

  """The chain id"""
  chainId: ChainId!
}

input WithdrawVaultRequest {
  """The vault address"""
  vault: EvmAddress!

  """
  The amount of assets to withdraw - you can pass in the underlying or the aToken if you pass in the aToken address it will withdraw with the aToke
  """
  amount: Erc20AmountInput!

  """
  The address from which vault shares will be burned (normally your own wallet).
  """
  sharesOwner: EvmAddress!

  """
  If you are doing the withdrawal from a trusted wallet which can move funds on behalf of the shares owner (advanced usage)
  """
  authorizedUser: EvmAddress

  """
  The address to which the underlying assets will be sent - defaults to sharesOwner.
  """
  recipient: EvmAddress

  """The chain id"""
  chainId: ChainId!
}

type _Service {
  sdl: String
}